<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cutelee: Extending the template system</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cutelee
   &#160;<span id="projectnumber">6.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Extending the template system </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="libraries"></a>
Filter and tag Libraries</h1>
<p>As already noted, it is possible for application developers to create their own tags and filters. This feature is based on the QtPlugin system so that plugins can be loaded at run time.</p>
<dl class="section note"><dt>Note</dt><dd>If you are already familiar with Django, you will know that this is not necessary on that system. That is because Django libraries are just python modules, which can behave like dynamically loaded plugins.</dd></dl>
<h2><a class="anchor" id="filters"></a>
Filters</h2>
<p>A filter takes an object and an optional argument and returns a string. To create your own filter, create a concrete subclass of <a class="el" href="classCutelee_1_1Filter.html" title="Base class for all filters.">Cutelee::Filter</a> and implement the <a class="el" href="classCutelee_1_1Filter.html#ab6f6256f376d0d1cc01d26dfa810aeaa">Filter::doFilter</a> method.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>TwiceFilter : <span class="keyword">public</span> <a class="code" href="classCutelee_1_1Filter.html">Cutelee::Filter</a></div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classQVariant.html">QVariant</a> dofilter(<span class="keyword">const</span> <a class="code" href="classQVariant.html">QVariant</a> &amp;input, <span class="keyword">const</span> <a class="code" href="classQVariant.html">QVariant</a> &amp;arg = <a class="code" href="classQVariant.html">QVariant</a>(), <span class="keywordtype">bool</span> autoescape = <span class="keyword">false</span>)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keyword">auto</span> str = <a class="code" href="namespaceCutelee.html#aad11e26ae1a92f997747cfbbe822463e">getSafeString</a>(input);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> str + str;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> isSafe()<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; } <span class="comment">// see the Autoescaping section</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">Seeing <span class="keywordtype">double</span> {{ name|twice }}?</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Renders: Seeing double MikeMike?</span></div>
<div class="ttc" id="aclassCutelee_1_1Filter_html"><div class="ttname"><a href="classCutelee_1_1Filter.html">Cutelee::Filter</a></div><div class="ttdoc">Base class for all filters.</div><div class="ttdef"><b>Definition:</b> <a href="filter_8h_source.html#l00058">filter.h:59</a></div></div>
<div class="ttc" id="aclassQVariant_html"><div class="ttname"><a href="classQVariant.html">QVariant</a></div><div class="ttdef"><b>Definition:</b> <a href="operatorcasttests_8cpp_source.html#l00030">operatorcasttests.cpp:31</a></div></div>
<div class="ttc" id="anamespaceCutelee_html_aad11e26ae1a92f997747cfbbe822463e"><div class="ttname"><a href="namespaceCutelee.html#aad11e26ae1a92f997747cfbbe822463e">Cutelee::getSafeString</a></div><div class="ttdeci">Cutelee::SafeString getSafeString(const QVariant &amp;input)</div><div class="ttdef"><b>Definition:</b> <a href="util_8cpp_source.html#l00108">util.cpp:108</a></div></div>
</div><!-- fragment --><p>The argument to doFilter is a <a class="el" href="classQVariant.html">QVariant</a>, so it may contain any of the types supported by Cutelee.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>RepeatFilter : <span class="keyword">public</span> <a class="code" href="classCutelee_1_1Filter.html">Cutelee::Filter</a></div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classQVariant.html">QVariant</a> dofilter(<span class="keyword">const</span> <a class="code" href="classQVariant.html">QVariant</a> &amp;input, <span class="keyword">const</span> <a class="code" href="classQVariant.html">QVariant</a> &amp;arg = <a class="code" href="classQVariant.html">QVariant</a>(), <span class="keywordtype">bool</span> autoescape = <span class="keyword">false</span>)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keyword">auto</span> str = <a class="code" href="namespaceCutelee.html#aad11e26ae1a92f997747cfbbe822463e">getSafeString</a>(input);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> ( arg.type() != QMetaType::Int )</div>
<div class="line">      <span class="keywordflow">return</span> str; <span class="comment">// Fail gracefully.</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> times = arg.toInt();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; times ++i)</div>
<div class="line">    {</div>
<div class="line">      str.get().append(str);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> str;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> isSafe()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">Seeing more {{ name|repeat:<span class="stringliteral">&quot;3&quot;</span> }}?</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Renders: Seeing more NathalieNathalieNathalie?</span></div>
<div class="line"> </div>
<div class="line">Seeing more {{ name|repeat:<span class="stringliteral">&quot;four&quot;</span> }}?</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Renders: Seeing more Otto? (failing gracefully)</span></div>
</div><!-- fragment --><p>Note that the filter does not fail or throw an exception if the integer conversion fails. Filters should handle all errors gracefully. If an error occurs, return either the input, or an empty string. Whichever is more appropriate.</p>
<h1><a class="anchor" id="autoescaping"></a>
Autoescaping and safe-ness</h1>
<p>When implementing filters, it is necessary to consider whether string output from the template should be escaped by Cutelee when rendering the template. Cutelee features an autoescaping feature which ensures that a string which should only be escaped once is not escaped two or more times.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="for_themers.html#templates_safestring">Autoescaping in templates.</a></dd></dl>
<p>The filter interface contains two elements relevant to autoescaping. The first is the <code>autoescape</code> parameter to the <a class="el" href="classCutelee_1_1Filter.html#ab6f6256f376d0d1cc01d26dfa810aeaa">Filter::doFilter</a> method. The <code>autoescape</code> parameter indicates the current autoescaping state of the renderer, which can be manipulated in templates with the <code>{%&#160;autoescape&#160;%}</code> tag. Use of the <code>autoescape</code> parameter is rare. The second element of autoescaping in the <a class="el" href="classCutelee_1_1Filter.html" title="Base class for all filters.">Filter</a> API is the <a class="el" href="classCutelee_1_1Filter.html#a9340d732ba707135a48bd19bc593759c">Filter::isSafe</a> method. This method can be reimplemented to indicate that a <a class="el" href="classCutelee_1_1Filter.html" title="Base class for all filters.">Filter</a> is 'safe' - that is - if given safe input, it produces safe output.</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://docs.djangoproject.com/en/dev/howto/custom-template-tags/#filters-and-auto-escaping">http://docs.djangoproject.com/en/dev/howto/custom-template-tags/#filters-and-auto-escaping</a> </dd>
<dd>
<a href="http://groups.google.com/group/django-users/browse_thread/thread/311f336d74e7b643">http://groups.google.com/group/django-users/browse_thread/thread/311f336d74e7b643</a></dd></dl>
<h2><a class="anchor" id="tags"></a>
Tags</h2>
<p>A tag can really do anything with a template. To create your own tag, create a concrete subclass of <a class="el" href="classCutelee_1_1AbstractNodeFactory.html" title="Base class for all NodeFactories.">Cutelee::AbstractNodeFactory</a> and implement the <a class="el" href="classCutelee_1_1AbstractNodeFactory.html#ac67b15a985f38c10a725ced437665c20">AbstractNodeFactory::getNode</a> method, and create a concrete subclass of <a class="el" href="classCutelee_1_1Node.html" title="Base class for all nodes.">Cutelee::Node</a> and implement the <a class="el" href="classCutelee_1_1Node.html#a55edab0142c583c6522a8bd3d5d8531d">Node::render</a> method.</p>
<dl class="section note"><dt>Note</dt><dd>If you are familiar with Django you will recognise that defining a tag in Django involves creating a <a class="el" href="classCutelee_1_1Node.html" title="Base class for all nodes.">Node</a> subclass (like Cutelee), and a factory function where Cutelee requires a factory class. This is because functions in python are objects, just like classes are, and dynamic typing allows easy creation of lists of those factory functions. In Cutelee with statically-typed C++, we need to group the factories by interface (i.e, the <a class="el" href="classCutelee_1_1AbstractNodeFactory.html" title="Base class for all NodeFactories.">Cutelee::AbstractNodeFactory</a> interface).</dd></dl>
<p>Tags can take arguments, advance the parser, create nodes, and generally have broad control over the parsing and rendering stages.</p>
<p>Here is an example of a <code>{%&#160;current_time&#160;%}</code> tag which displays the current time.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CurrentTimeNode : <span class="keyword">public</span> <a class="code" href="classCutelee_1_1Node.html">Cutelee::Node</a></div>
<div class="line">{</div>
<div class="line">      Q_OBJECT</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">public</span>:</div>
<div class="line">      CurrentTimeNode( QObject *parent = {} )</div>
<div class="line">         : <a class="code" href="classCutelee_1_1Node.html">Cutelee::Node</a>( parent )</div>
<div class="line">      {</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">void</span> render( <a class="code" href="classCutelee_1_1OutputStream.html">Cutelee::OutputStream</a> *stream, <a class="code" href="classCutelee_1_1Context.html">Cutelee::Context</a> *c)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">      </span>{</div>
<div class="line">         Q_UNUSED(c);</div>
<div class="line">         </div>
<div class="line">         (*stream) &lt;&lt;  QDateTime::currentDateTime().toString();</div>
<div class="line">      }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>CurrentTimeTagFactory : <span class="keyword">public</span> <a class="code" href="classCutelee_1_1AbstractNodeFactory.html">Cutelee::AbstractNodeFactory</a></div>
<div class="line">{</div>
<div class="line">      <a class="code" href="classCutelee_1_1Node.html">Cutelee::Node</a> *getNode(<span class="keyword">const</span> <a class="code" href="classQString.html">QString</a> &amp;tagContent, <a class="code" href="classCutelee_1_1Parser.html">Cutelee::Parser</a> *p)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">      </span>{</div>
<div class="line">         Q_UNUSED(p);</div>
<div class="line"> </div>
<div class="line">         <span class="comment">// You almost always want to use smartSplit.</span></div>
<div class="line">         QStringList parts = smartSplit(tagContent);</div>
<div class="line">         parts.removeFirst(); <span class="comment">// Not interested in the name of the tag.</span></div>
<div class="line"> </div>
<div class="line">         <span class="keywordflow">if</span> (!parts.isEmpty())</div>
<div class="line">            <span class="comment">// The remaining parts are the arguments to the tag. If an incorrect number of arguments</span></div>
<div class="line">            <span class="comment">// is supplied, and exception should be thrown.</span></div>
<div class="line">            <span class="keywordflow">throw</span> <a class="code" href="classCutelee_1_1Exception.html">Cutelee::Exception</a>( Cutelee::TagSyntaxError, <span class="stringliteral">&quot;current_time does not take any arguments&quot;</span> );</div>
<div class="line"> </div>
<div class="line">         <span class="keywordflow">return</span> <span class="keyword">new</span> CurrentTimeNode();</div>
<div class="line">      }</div>
<div class="line">};</div>
<div class="ttc" id="aclassCutelee_1_1AbstractNodeFactory_html"><div class="ttname"><a href="classCutelee_1_1AbstractNodeFactory.html">Cutelee::AbstractNodeFactory</a></div><div class="ttdoc">Base class for all NodeFactories.</div><div class="ttdef"><b>Definition:</b> <a href="node_8h_source.html#l00299">node.h:300</a></div></div>
<div class="ttc" id="aclassCutelee_1_1Context_html"><div class="ttname"><a href="classCutelee_1_1Context.html">Cutelee::Context</a></div><div class="ttdoc">The Context class holds the context to render a Template with.</div><div class="ttdef"><b>Definition:</b> <a href="context_8h_source.html#l00118">context.h:119</a></div></div>
<div class="ttc" id="aclassCutelee_1_1Exception_html"><div class="ttname"><a href="classCutelee_1_1Exception.html">Cutelee::Exception</a></div><div class="ttdoc">An exception for use when implementing template tags.</div><div class="ttdef"><b>Definition:</b> <a href="exception_8h_source.html#l00084">exception.h:85</a></div></div>
<div class="ttc" id="aclassCutelee_1_1Node_html"><div class="ttname"><a href="classCutelee_1_1Node.html">Cutelee::Node</a></div><div class="ttdoc">Base class for all nodes.</div><div class="ttdef"><b>Definition:</b> <a href="node_8h_source.html#l00077">node.h:78</a></div></div>
<div class="ttc" id="aclassCutelee_1_1OutputStream_html"><div class="ttname"><a href="classCutelee_1_1OutputStream.html">Cutelee::OutputStream</a></div><div class="ttdoc">The OutputStream class is used to render templates to a QTextStream.</div><div class="ttdef"><b>Definition:</b> <a href="outputstream_8h_source.html#l00080">outputstream.h:81</a></div></div>
<div class="ttc" id="aclassCutelee_1_1Parser_html"><div class="ttname"><a href="classCutelee_1_1Parser.html">Cutelee::Parser</a></div><div class="ttdoc">The Parser class processes a string template into a tree of nodes.</div><div class="ttdef"><b>Definition:</b> <a href="parser_8h_source.html#l00048">parser.h:49</a></div></div>
<div class="ttc" id="aclassQString_html"><div class="ttname"><a href="classQString.html">QString</a></div><div class="ttdef"><b>Definition:</b> <a href="operatorcasttests_8cpp_source.html#l00023">operatorcasttests.cpp:24</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classCutelee_1_1AbstractNodeFactory.html#aef083f10ad3ea66bacec461603bd6f32">AbstractNodeFactory::smartSplit</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The current_time tag could be extended to format the time in a particular way. That is the behaviour of the <code>{%&#160;now&#160;%}</code> tag. See its documentation and implementation for details.</dd></dl>
<p>Also, note that, <a class="el" href="classCutelee_1_1AbstractNodeFactory.html#ac67b15a985f38c10a725ced437665c20">AbstractNodeFactory::getNode</a> implementation may throw an execption at template compilation time, but like implementations of <a class="el" href="classCutelee_1_1Filter.html#ab6f6256f376d0d1cc01d26dfa810aeaa">Filter::doFilter</a>, implememtations of <a class="el" href="classCutelee_1_1Node.html#a55edab0142c583c6522a8bd3d5d8531d">Node::render</a> should return an empty <a class="el" href="classQString.html">QString</a> in most error cases.</p>
<h2><a class="anchor" id="tags_with_end_tags"></a>
Tags with end tags</h2>
<p>Often, tags will be not just one token in a template, but a start and end token such as <code>range</code>, <code>spaceless</code>, <code>with</code>, or a start, middle and end tokens, such as <code>if</code> and <code>for</code>.</p>
<p>When constructing a <a class="el" href="classCutelee_1_1Node.html" title="Base class for all nodes.">Node</a>, a <a class="el" href="classCutelee_1_1AbstractNodeFactory.html" title="Base class for all NodeFactories.">AbstractNodeFactory</a> implementation can instruct the <a class="el" href="classCutelee_1_1Parser.html" title="The Parser class processes a string template into a tree of nodes.">Parser</a> to parse until any appropriate <a class="el" href="structCutelee_1_1Token.html">Token</a>.</p>
<div class="fragment"><div class="line">text content</div>
<div class="line">{% <span class="keywordflow">if</span> foo %}</div>
<div class="line">  foo content</div>
<div class="line">{% <span class="keywordflow">else</span> %}</div>
<div class="line">  <span class="keywordflow">default</span> content</div>
<div class="line">{% endif %}</div>
<div class="line">end content</div>
</div><!-- fragment --><p>To implement such a tag the implementation of <a class="el" href="classCutelee_1_1AbstractNodeFactory.html#ac67b15a985f38c10a725ced437665c20">AbstractNodeFactory::getNode</a> needs to parse until the optional intermediate tags and until the mandatory end tag, collecting the child nodes as it does so.</p>
<div class="fragment"><div class="line">Node* <a class="code" href="classIfNodeFactory.html#a035a013ac7fdbb029b8d912bd2b5325c">IfNodeFactory::getNode</a>( <span class="keyword">const</span> <a class="code" href="classQString.html">QString</a> &amp;tagContent, Parser *p )<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  QStringList parts = smartSplit( tagContent );</div>
<div class="line">  parts.removeFirst(); <span class="comment">// Remove &quot;if&quot;</span></div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Error handling etc.</span></div>
<div class="line">  </div>
<div class="line">  <span class="keyword">auto</span> argsList = getFilterExpressionList( parts );</div>
<div class="line">  <span class="keyword">auto</span> node = <span class="keyword">new</span> <a class="code" href="classIfNode.html">IfNode</a>( argsList, p );</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Parse until an else or endif token</span></div>
<div class="line">  <span class="keyword">auto</span> trueList = p-&gt;parse( node, QStringList{<span class="stringliteral">&quot;else&quot;</span>, <span class="stringliteral">&quot;endif&quot;</span>} );</div>
<div class="line">  node-&gt;setTrueList( trueList );</div>
<div class="line">  <span class="keyword">auto</span> falseList;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> nextToken = p-&gt;takeNextToken();</div>
<div class="line">  <span class="keywordflow">if</span> ( nextToken.content == <span class="stringliteral">&quot;else&quot;</span> )</div>
<div class="line">  {</div>
<div class="line">    falseList = p-&gt;parse( node, <span class="stringliteral">&quot;endif&quot;</span> );</div>
<div class="line">    node-&gt;setFalseList( falseList );</div>
<div class="line">    <span class="comment">// skip past the endif tag</span></div>
<div class="line">    p-&gt;removeNextToken();</div>
<div class="line">  } <span class="comment">// else empty falseList.</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> node;</div>
<div class="line">}</div>
<div class="ttc" id="aclassIfNodeFactory_html_a035a013ac7fdbb029b8d912bd2b5325c"><div class="ttname"><a href="classIfNodeFactory.html#a035a013ac7fdbb029b8d912bd2b5325c">IfNodeFactory::getNode</a></div><div class="ttdeci">Node * getNode(const QString &amp;tagContent, Parser *p) const override</div><div class="ttdef"><b>Definition:</b> <a href="if_8cpp_source.html#l00029">if.cpp:29</a></div></div>
<div class="ttc" id="aclassIfNode_html"><div class="ttname"><a href="classIfNode.html">IfNode</a></div><div class="ttdef"><b>Definition:</b> <a href="if_8h_source.html#l00039">if.h:40</a></div></div>
</div><!-- fragment --><p>There is no limit to the number of intermediate tokens you can use in your tags. For example, a better <code>{%&#160;if&#160;%}</code> tag might support multiple elif tags.</p>
<div class="fragment"><div class="line">text content</div>
<div class="line">{% <span class="keywordflow">if</span> foo %}</div>
<div class="line">  foo content</div>
<div class="line">{% elif bar %}</div>
<div class="line">  bar content</div>
<div class="line">{% elif bat %}</div>
<div class="line">  bat content</div>
<div class="line">{% <span class="keywordflow">else</span> %}</div>
<div class="line">  <span class="keywordflow">default</span> content</div>
<div class="line">{% endif %}</div>
<div class="line">end content</div>
</div><!-- fragment --><h1><a class="anchor" id="cpp_libraries"></a>
C++ Libraries</h1>
<p>As already mentioned, it is neccessary to create a QtPlugin library to make your tags and filters available to Cutelee. You need to implement <a class="el" href="classCutelee_1_1TagLibraryInterface.html" title="The TagLibraryInterface returns available tags and filters from libraries.">TagLibraryInterface</a> to return your custom node factories and filters. See the existing libraries in your Cutelee distribution for full examples.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cutelee/taglibraryinterface.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;mytag.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;myfilter.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyLibrary : <span class="keyword">public</span> QObject, <span class="keyword">public</span> <a class="code" href="classCutelee_1_1TagLibraryInterface.html">Cutelee::TagLibraryInterface</a></div>
<div class="line">{</div>
<div class="line">  Q_OBJECT</div>
<div class="line">  Q_INTERFACES( <a class="code" href="classCutelee_1_1TagLibraryInterface.html">Cutelee::TagLibraryInterface</a> )</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MyLibrary(QObject *parent = 0)</div>
<div class="line">    : QObject (parent)</div>
<div class="line">  {</div>
<div class="line">    m_nodeFactories.insert(<span class="stringliteral">&quot;mytag&quot;</span>, <span class="keyword">new</span> MyNodeFactory());</div>
<div class="line"> </div>
<div class="line">    m_filters.insert(<span class="stringliteral">&quot;myfilter&quot;</span>, <span class="keyword">new</span> MyFilter());</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  QHash&lt;QString, Cutelee::AbstractNodeFactory*&gt; nodeFactories(<span class="keyword">const</span> <a class="code" href="classQString.html">QString</a> &amp;name = <a class="code" href="classQString.html">QString</a>())</div>
<div class="line">  {</div>
<div class="line">    Q_UNUSED(name);</div>
<div class="line">    <span class="keywordflow">return</span> m_nodeFactories;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  QHash&lt;QString, Cutelee::Filter*&gt; filters(<span class="keyword">const</span> <a class="code" href="classQString.html">QString</a> &amp;name = <a class="code" href="classQString.html">QString</a>())</div>
<div class="line">  {</div>
<div class="line">    Q_UNUSED(name);</div>
<div class="line">    <span class="keywordflow">return</span> m_filters;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="aclassCutelee_1_1TagLibraryInterface_html"><div class="ttname"><a href="classCutelee_1_1TagLibraryInterface.html">Cutelee::TagLibraryInterface</a></div><div class="ttdoc">The TagLibraryInterface returns available tags and filters from libraries.</div><div class="ttdef"><b>Definition:</b> <a href="taglibraryinterface_8h_source.html#l00079">taglibraryinterface.h:80</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="javascript_libraries"></a>
Javascript Libraries</h1>
<p>If you configure your application to use the cutelee_scriptabletags_library, it will be possible for you and theme writers to write tags and filters in Javascript instead of C++. Themers would have as much control as a C++ plugin writer over those steps of processing and rendering the template.</p>
<p>Writing Javascript plugins is slightly different from writing C++ plugins, and is a bit more like writing Django plugins. Namely, in Javascript like python, functions are first-class objects, and Javascript is dynamically typed. Additionally Javascript plugins are just text files, so they can easily be dynamically loaded at runtime. Javascript files must be UTF-8 encoded.</p>
<p>Here is a complete Javascript library defining an <code>{%&#160;echo&#160;%}</code> tag which outputs its arguments:</p>
<div class="fragment"><div class="line">var EchoNode = <span class="keyword">function</span>(content)</div>
<div class="line">{</div>
<div class="line">  this.content = content;</div>
<div class="line">  this.render = <span class="keyword">function</span>(context)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> content.join(<span class="stringliteral">&quot; &quot;</span>);</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">function</span> EchoNodeFactory(tagContent, parser)</div>
<div class="line">{</div>
<div class="line">  var content = tagContent.split(<span class="stringliteral">&quot; &quot;</span>);</div>
<div class="line">  content = content.slice(1, content.length);</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">new</span> Node(<span class="stringliteral">&quot;EchoNode&quot;</span>, content);</div>
<div class="line">};</div>
<div class="line">EchoNodeFactory.tagName = <span class="stringliteral">&quot;echo&quot;</span>;</div>
<div class="line">Library.addFactory(<span class="stringliteral">&quot;EchoNodeFactory&quot;</span>);</div>
</div><!-- fragment --><p>Some things to note:</p><ul>
<li><code>Library</code> is a globally accessible object used to register <code>Factories</code>.</li>
<li>The <code>addFactory</code> method takes a string which is the name of an object, not the object itself.</li>
<li>The script factory function returns a <code>Node</code>. The first argument to <code>Node</code> is the name of the Javascript object in the library which defines the node. All additional arguments will be passed to the constructor of that node.</li>
<li><p class="startli">The Node function must have a callable render property which takes a context argument.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>@section javascript_diff Differences between C++ and Javascript library plugins.</dd></dl>
</li>
</ul>
<h2><a class="anchor" id="loaders"></a>
Loaders</h2>
<p>As noted in <a class="el" href="for_app_dev.html#creating_templates">Creating Templates</a>, you will usually not create a <a class="el" href="classCutelee_1_1Template.html" title="The Template class is a tree of nodes which may be rendered.">Template</a> directly, but retrieve it from an <a class="el" href="classCutelee_1_1Engine.html" title="Cutelee::Engine is the main entry point for creating Cutelee Templates.">Engine</a> instance. The <a class="el" href="classCutelee_1_1Engine.html" title="Cutelee::Engine is the main entry point for creating Cutelee Templates.">Engine</a> allows you to define where the templates are retrieved from when you request them by name.</p>
<p>You can redefine the order of places in the filesystem which are searched for templates, and even define new ways to retrieve templates (i.e, not from the filesystem) by subclassing <a class="el" href="classCutelee_1_1AbstractTemplateLoader.html" title="An retrieval interface to a storage location for Template objects.">Cutelee::AbstractTemplateLoader</a> and implementing the <a class="el" href="classCutelee_1_1AbstractTemplateLoader.html#a1c33f9cf6e5e26cc465fb61e74149490">AbstractTemplateLoader::loadByName</a> method. For existing loaders, see <a class="el" href="classCutelee_1_1FileSystemTemplateLoader.html" title="The FileSystemTemplateLoader loads Templates from the file system.">FileSystemTemplateLoader</a>, <a class="el" href="classCutelee_1_1InMemoryTemplateLoader.html" title="The InMemoryTemplateLoader loads Templates set dynamically in memory.">InMemoryTemplateLoader</a>, and AkonadiTemplateLoader. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
