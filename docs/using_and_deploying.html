<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cutelee: Using Cutelee in your application</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cutelee
   &#160;<span id="projectnumber">6.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Using Cutelee in your application </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Using Cutelee in Qt applications will often not require much code.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> engine = getEngine();</div>
<div class="line"><span class="keyword">auto</span> t = engine-&gt;loadByName( <span class="stringliteral">&quot;mytemplate.html&quot;</span> );</div>
<div class="line">Context c;</div>
<div class="line">c.insert( <span class="stringliteral">&quot;some_input&quot;</span>, some_value );</div>
<div class="line">browser.setHtml( t-&gt;render( c ) );</div>
</div><!-- fragment --><p>Error handling etc is omitted for clarity. In order for the above to work as expected, it is necessary to configure the build system to find Cutelee, and to configure Cutelee to find templates and plugins.</p>
<h1><a class="anchor" id="finding_with_cmake"></a>
Finding Cutelee with CMake</h1>
<p>Cutelee uses the <a href="http://www.cmake.org/">CMake</a> cross platform build system, and installs a cmake file called <code>Cutelee6Config.cmake</code>. This config file is automatically searched for by CMake and contains the information needed for other CMake based applications to find headers and link against Cutelee libraries. See <a href="https://cmake.org/cmake/help/latest/manual/cmake-packages.7.html">https://cmake.org/cmake/help/latest/manual/cmake-packages.7.html</a> for more.</p>
<p>When creating an application using CMake that depends on Cutelee, first issue the <code>find_package</code> command, and then use the CMake <code>target_link_libraries</code> command link to and use the libraries.</p>
<div class="fragment"><div class="line">project(my_application)</div>
<div class="line"> </div>
<div class="line">cmake_minimum_required(VERSION 2.8.11)</div>
<div class="line"> </div>
<div class="line">set(CMAKE_AUTOMOC ON)</div>
<div class="line">set(CMAKE_INCLUDE_CURRENT_DIR ON)</div>
<div class="line"> </div>
<div class="line">find_package(<a class="code" href="namespaceCutelee.html">Cutelee</a> 6 REQUIRED)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># ... Application sources etc.</span></div>
<div class="line"> </div>
<div class="line">target_link_libraries(my_application </div>
<div class="line">  PRIVATE</div>
<div class="line">    Qt5::Widgets</div>
<div class="line">    Cutelee::Templates</div>
<div class="line">)</div>
<div class="ttc" id="anamespaceCutelee_html"><div class="ttname"><a href="namespaceCutelee.html">Cutelee</a></div><div class="ttdoc">The Cutelee namespace holds all public Cutelee API.</div><div class="ttdef"><b>Definition:</b> <a href="Mainpage_8dox_source.html#l00007">Mainpage.dox:8</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="deploying_templates"></a>
Deploying Templates</h1>
<p>Template files can be installed by your application and must later be found by Cutelee so they can be used. If the files are installed on the filesystem, the path they were installed to can be specified when creating a <a class="el" href="classCutelee_1_1AbstractTemplateLoader.html" title="An retrieval interface to a storage location for Template objects.">AbstractTemplateLoader</a> instance.</p>
<div class="fragment"><div class="line">Engine* getEngine()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> engine = <span class="keyword">new</span> Engine( <span class="keyword">this</span> );</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> loader = std::shared_ptr&lt;FileSystemTemplateLoader&gt;::create();</div>
<div class="line">  loader-&gt;setTemplateDirs( QStringList{ path_to_installed_templates } );</div>
<div class="line"> </div>
<div class="line">  engine-&gt;addTemplateLoader( loader );</div>
<div class="line">  <span class="keywordflow">return</span> engine;</div>
<div class="line">}</div>
</div><!-- fragment --><p>It is also possible to compile the templates into a <a href="https://doc.qt.io/qt-5/resources.html">Qt Resource</a> file and set the resource URL on the <a class="el" href="classCutelee_1_1AbstractTemplateLoader.html" title="An retrieval interface to a storage location for Template objects.">AbstractTemplateLoader</a> instance.</p>
<p>my_app_templates.qrc: </p><div class="fragment"><div class="line">&lt;!DOCTYPE RCC&gt;&lt;RCC version=<span class="stringliteral">&quot;1.0&quot;</span>&gt;</div>
<div class="line">&lt;qresource&gt;</div>
<div class="line">    &lt;file&gt;mybasetemplate.html&lt;/file&gt;</div>
<div class="line">    &lt;file&gt;mytemplate.html&lt;/file&gt;</div>
<div class="line">    &lt;file&gt;myothertemplate.html&lt;/file&gt;</div>
<div class="line">&lt;/qresource&gt;</div>
<div class="line">&lt;/RCC&gt;</div>
</div><!-- fragment --><p>CMake code: </p><div class="fragment"><div class="line">set (_rcc_file <span class="stringliteral">&quot;my_app_templates.qrc&quot;</span>)</div>
<div class="line">qt5_add_resources(_template_rcc_src ${_rcc_file} OPTIONS -root <span class="stringliteral">&quot;/templates/&quot;</span> )</div>
<div class="line"> </div>
<div class="line">add_executable(my_app, ${my_app_srcs} ${_template_rcc_src})</div>
</div><!-- fragment --><p>Application code:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> loader = std::shared_ptr&lt;FileSystemTemplateLoader&gt;::create();</div>
<div class="line">loader-&gt;setTemplateDirs( QStringList{ <span class="stringliteral">&quot;:/templates/&quot;</span> } );</div>
<div class="line"> </div>
<div class="line">engine-&gt;addTemplateLoader( loader );</div>
</div><!-- fragment --><p>The <code>-root</code> option passed to <code>rcc</code> in CMake causes the templates to be in the virtual filesystem location &quot;<code>:/templates/mytemplate.html</code>&quot; etc. This name spacing helps keep independent data in the virtual filesystem separate.</p>
<h1><a class="anchor" id="finding_user_templates"></a>
Finding user defined templates</h1>
<p>If users are able to define their own templates in an application that uses Cutelee for theming for example, the path to the location of such potential templates must also be set through the <a class="el" href="classCutelee_1_1AbstractTemplateLoader.html" title="An retrieval interface to a storage location for Template objects.">AbstractTemplateLoader</a> instance. Paths to user defined templates should be defined before default/installed templates so that the user templates are found first. If there is a reason to disallow user overriding of certain templates, they can be specified in a separate <a class="el" href="classCutelee_1_1AbstractTemplateLoader.html" title="An retrieval interface to a storage location for Template objects.">AbstractTemplateLoader</a> instance.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> no_override_loader = std::shared_ptr&lt;FileSystemTemplateLoader&gt;::create();</div>
<div class="line">no_override_loader-&gt;setTemplateDirs( </div>
<div class="line">    QStringList{ path_to_non_overridable_templates } </div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">engine-&gt;addTemplateLoader( no_override_loader );</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> override_loader = std::shared_ptr&lt;FileSystemTemplateLoader&gt;::create();</div>
<div class="line">override_loader-&gt;setTemplateDirs( </div>
<div class="line">    QStringList{ path_to_user_templates, path_to_default_templates } </div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">engine-&gt;addTemplateLoader( override_loader );</div>
</div><!-- fragment --><p>Additionally, the <a href="https://doc.qt.io/qt-5/resources.html#external-binary-resources">External binary resources</a> feature could be used to allow savvy users to share themes/templates in a package, or to deploy updated templates easily to existing deployed applications.</p>
<h1><a class="anchor" id="finding_plugins"></a>
Finding tags and filters</h1>
<p>Cutelee looks for plugins in the paths from the <a class="el" href="classCutelee_1_1Engine.html#a06ae5bb093d642994e2967668a592eaf">Engine::pluginPaths</a> property. It does so in the same order they appear there.</p>
<p>The property defaults to the following directories</p><ul>
<li>The default plugin directory of your Qt installation (<code>qmake -query QT_INSTALL_PLUGINS</code>).</li>
<li>The directories specified in the environment variable <code>QT_PLUGIN_DIR</code>.</li>
<li>The default plugin directory of your Cutelee installation.</li>
</ul>
<p>Each path has <code>&quot;cutelee/$version/&quot;</code> appended to it, and the resulting directory is searched for plugins. For example, if the version of Cutelee is 5.0 and QCoreApplication::libraryPaths() contains <code>&quot;/usr/lib/plugins/&quot;</code>, the directory <code>&quot;/usr/lib/plugins/cutelee/5.0&quot;</code> would be searched for plugins. The search stops when a plugin matching a particular name is found.</p>
<p>The paths used to search for plugins can be overriden by using <a class="el" href="classCutelee_1_1Engine.html#a3b4e1dbc912075a82806af370ddf38b3">Engine::setPluginPaths</a>. If you just want to add some additional paths use <a class="el" href="classCutelee_1_1Engine.html#a6acd17138f526ad7f3f95c2604f5366e">Engine::addPluginPath</a>. The added path will be prepended to the list of search paths.</p>
<h1><a class="anchor" id="deploying_custom_plugins"></a>
Deploying custom tags and filters</h1>
<p>Custom tags and filters can be defined in C++ code or in Javascript.</p>
<p>To create a custom C++ plugin it must be built as part of a library and installed in a location known to the application.</p>
<div class="fragment"><div class="line"><span class="preprocessor"># CMake code</span></div>
<div class="line"> </div>
<div class="line">add_library(my_custom_plugin MODULE</div>
<div class="line">  custom_plugin_library.cpp</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">install(TARGETS my_custom_plugin</div>
<div class="line">        RUNTIME DESTINATION ${PLUGIN_INSTALL_DIR}</div>
<div class="line">        LIBRARY DESTINATION ${PLUGIN_INSTALL_DIR}</div>
<div class="line">        ARCHIVE DESTINATION ${LIB_INSTALL_DIR}</div>
<div class="line">        COMPONENT Devel</div>
<div class="line">)</div>
</div><!-- fragment --><p>In this case, <code>my_custom_plugin</code> is a name used for the plugin in the CMake environment. It is used to install the custom library in the CMake <code>install</code> command.</p>
<p><code>custom_plugin_library.cpp</code> is the C++ file where you implement the <a class="el" href="classCutelee_1_1TagLibraryInterface.html" title="The TagLibraryInterface returns available tags and filters from libraries.">Cutelee::TagLibraryInterface</a> to return custom tags and filters.</p>
<p>Note that the <code>PLUGIN_INSTALL_DIR</code> given to the install command should contain the version number of Cutelee used to create the custom library. For example, <code>/usr/share/my_app/plugins/cutelee/5.0/</code>.</p>
<p>In C++ code, it is necessary to either instruct the <a class="el" href="classCutelee_1_1Engine.html" title="Cutelee::Engine is the main entry point for creating Cutelee Templates.">Cutelee::Engine</a> about the location of the plugins or to configure your QCoreApplication::libraryPaths by another standard method. Note that it is possible to define custom versions of built in tags and filters by putting your own plugin library in the path before the path to the default Cutelee plugins.</p>
<p>For example, if your custom plugin library contained a custom implementation of the <code>{%&#160;for&#160;%}</code> tag: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> engine = <span class="keyword">new</span> Engine( <span class="keyword">this</span> );</div>
<div class="line">engine-&gt;setPluginPaths( </div>
<div class="line">    QStringList{ path_to_custom_plugins, path_to_cutelee_defaults } </div>
<div class="line">    );</div>
</div><!-- fragment --><p>Note that neither the path to the custom libarary nor the path to the Cutelee default library should contain the version number when specified in C++ code with the <a class="el" href="classCutelee_1_1Engine.html" title="Cutelee::Engine is the main entry point for creating Cutelee Templates.">Engine</a>. The version is only specified when installing the plugin in CMake.</p>
<p>Custom tags and filters implemented in Javascript can also be deployed on the file system, or, like template files, can also be deployed in Qt Resource files. In that case, the version should be specified in the -root argument in CMake.</p>
<div class="fragment"><div class="line"><span class="preprocessor"># CMake code:</span></div>
<div class="line">set (_rcc_file <span class="stringliteral">&quot;my_qtscript_library.qrc&quot;</span>)</div>
<div class="line">qt5_add_resources(_scripted_rcc_src </div>
<div class="line">    ${_rcc_file} </div>
<div class="line">    OPTIONS -root <span class="stringliteral">&quot;/plugins/cutelee/${Cutelee_VERSION_MAJOR}.${Cutelee_VERSION_MINOR}&quot;</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">add_executable(my_app, ${my_app_srcs} ${_scripted_rcc_src})</div>
<div class="line"> </div>
<div class="line"># C++ code:</div>
<div class="line">engine-&gt;setPluginPaths( QStringList{ <span class="stringliteral">&quot;:/plugins/&quot;</span> } );</div>
</div><!-- fragment --><p>Note again that when specifying the path in the virtual filesystem, the version is omitted. User defined filter written in Javascript can also be located similiarly to templates from either the filesystem or the Qt Resource virtual filesystem.</p>
<h1><a class="anchor" id="building_cutelee"></a>
Building Cutelee</h1>
<p>It is possible to build only parts of Cutelee if your application is a QCoreApplication that depends only on QtCore</p>
<p>The appropriate options may be specified in the cmake gui, or on the command line using the <code>BUILD_TEXTDOCUMENT</code> or <code>BUILD_TEMPLATES</code> CMake options.</p>
<div class="fragment"><div class="line">mkdir build &amp;&amp; cd build</div>
<div class="line">cmake .. -DBUILD_TEXTDOCUMENT=OFF -DBUILD_TESTS=OFF</div>
</div><!-- fragment --><p>Similarly, it is possible to build only the core of the Cutelee <a class="el" href="classCutelee_1_1Template.html" title="The Template class is a tree of nodes which may be rendered.">Template</a> library without the plugins. This may be useful for specialized applications, but as the unit tests depend on the plugins, the tests would need to be deactivated in this case too:</p>
<div class="fragment"><div class="line">mkdir build &amp;&amp; cd build</div>
<div class="line">cmake .. -DBUILD_TEXTDOCUMENT=OFF -DBUILD_TESTS=OFF -DBUILD_MAIN_PLUGINS=OFF</div>
</div><!-- fragment --><p>By default, Cutelee depends on the QtQml library in order to implement Javascript support. This support is only enabled if the QtQml library is found.</p>
<center> <b> <div class="dotgraph">
<img src="dot_moduledeps.png" alt="dot_moduledeps.png" border="0" usemap="#dot_moduledeps.map"/>
<div class="caption">
Dependency Graph for Cutelee</div>
</div>
 </b> </center><p>To prevent CMake searching for that library, use the <code>-DCMAKE_DISABLE_FIND_PACKAGE_Qt5Qml=ON</code> argument to CMake.</p>
<center> <b> <div class="dotgraph">
<img src="dot_moduledeps_no_qml.png" alt="dot_moduledeps_no_qml.png" border="0" usemap="#dot_moduledeps_no_qml.map"/>
<div class="caption">
Dependency Graph for Cutelee without QtQml</div>
</div>
 </b> </center> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
